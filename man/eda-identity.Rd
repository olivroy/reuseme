% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eda-identity.R
\name{eda-identity}
\alias{eda-identity}
\alias{names_identity}
\alias{count_identity}
\alias{mutate_identity}
\alias{slice_min_identity}
\alias{slice_max_identity}
\alias{arrange_identity}
\alias{distinct_identity}
\alias{filter_identity}
\alias{slice_sample_identity}
\alias{filter_if_any_identity}
\alias{slice_min_max_identity}
\alias{slice_group_sample_identity}
\title{Helpers that return the same value}
\usage{
names_identity(x, nrows = NULL, extra_msg = NULL)

count_identity(
  x,
  ...,
  sort = TRUE,
  name = NULL,
  nrows = NULL,
  extra_msg = NULL
)

mutate_identity(
  x,
  ...,
  .keep = NULL,
  .before = NULL,
  nrows = NULL,
  extra_msg = NULL
)

slice_min_identity(
  x,
  order_by,
  ...,
  n,
  prop,
  by = NULL,
  with_ties = TRUE,
  na_rm = TRUE,
  nrows = NULL,
  extra_msg = NULL
)

slice_max_identity(
  x,
  order_by,
  ...,
  n,
  prop,
  by = NULL,
  with_ties = TRUE,
  na_rm = TRUE,
  nrows = NULL,
  extra_msg = NULL
)

arrange_identity(x, ..., .by_group = FALSE, nrows = NULL, extra_msg = NULL)

distinct_identity(x, ..., .keep_all = FALSE, nrows = NULL, extra_msg = NULL)

filter_identity(x, ..., .by = NULL, nrows = NULL, extra_msg = NULL)

slice_sample_identity(
  x,
  ...,
  n,
  prop,
  by = NULL,
  weight_by = NULL,
  replace = FALSE,
  nrows = NULL,
  extra_msg = NULL
)

filter_if_any_identity(x, ..., .keep = NULL, nrows = NULL, extra_msg = NULL)

slice_min_max_identity(
  x,
  order_by,
  each = FALSE,
  ...,
  n,
  prop,
  by = NULL,
  with_ties = TRUE,
  na_rm = FALSE,
  nrows = NULL,
  extra_msg = NULL
)

slice_group_sample_identity(
  x,
  n_groups = 1,
  group_var = NULL,
  nrows = NULL,
  extra_msg = NULL
)
}
\arguments{
\item{x}{The main object (a data.frame, but some functions accept a vector.) (aka \code{.data} in some \code{dplyr} functions, but naming it \code{x} throughout.)}

\item{nrows}{Number of rows to print}

\item{extra_msg}{A character vector of observations, notes taken related to the transformation.}

\item{name, sort, .keep_all, .by, by, n_groups, group_var, ..., n, prop, with_ties, order_by, .keep, .before, each, na_rm, weight_by, replace, .by_group}{Check original functions.}
}
\value{
\code{x} original \code{x} is (invisibly) returned. (allowing the \verb{*_identity()}
functions to be used in a pipeline) will print \code{extra_msg} to the console in interactive sessions.
}
\description{
They all share the \verb{*_identity} suffix, they are silent in non-interactive sessions
They are very handy to create runnable hyperlinks that do not modify the current state of the analysis

They are inspired by \link[pillar:glimpse]{pillar::glimpse}, \link[tibble:view]{tibble::view},

Look at the original functions for the other parameters.
}
\section{Use cases / advantages}{
\itemize{
\item Like many other reuseme functions, they are most useful in interactive sessions
\item print the result in interactive sessions (quiet in non-interactive.)
\item Create runnable hyperlinks (In July 2023, RStudio forbids runnable hyperlinks of base functions, or non-package functions. (i.e. that don't have \code{::}))
\item Use in pipelines to explore the data
\item Use \code{\link[rlang:is_interactive]{rlang::is_interactive()}} over \code{\link[base:interactive]{base::interactive()}} as it's easier to
control and test with \code{options(rlang_interactive)}
\item Use the original functions for your final results.
\item \code{count_identity()} also prints percentages.
}
}

\section{Caution}{
\itemize{
\item Don't put those at the end of a pipeline
\item Don't name the first argument, to avoid conflicts in case a variable is named \code{x}.
\item Some functions have small tweaks
\itemize{
\item \code{mutate_identity()} only prints the distinct values, and uses \code{.keep = "used"}, \code{.before = 0},
unless specified to improve the display.
\item \code{count_identity()} is a wrapper of \code{count_pct()} (wrapper of \code{dplyr::count()}),
may fail if there is already a variable named \code{n}.
\item \code{slice_min/max_identity()} relocates the target column at the beginning.
\item \code{filter_identity()} prints a short message if no rows are returned.
}
}
}

\examples{
withr::local_options(rlang_interactive = TRUE)
# Workflow to explore mtcars
library(magrittr)
mtcars \%>\%
  filter_identity(mpg > 21, extra_msg = c("Wow, these rows are very interesting.")) \%>\%
  count_identity(
    vs,
    extra_msg = c(
      "Woo, there are 14 obs with vs = 1, 18 obs with vs = 0",
      "The split is 56\%-43\%"
    )
  ) \%>\%
  dplyr::filter(disp > 150) # after all, I need only disp > 150

}
\seealso{
\itemize{
\item \code{\link[dplyr:distinct]{dplyr::distinct()}}
\item \code{\link[dplyr:filter]{dplyr::filter()}}
\item \code{\link[dplyr:slice]{dplyr::slice()}}
\item \code{\link[dplyr:mutate]{dplyr::mutate()}}
\item \code{\link[dplyr:arrange]{dplyr::arrange()}}
\item \code{\link[=count_pct]{count_pct()}}
\item \code{\link[=slice_min_max]{slice_min_max()}}
\item \code{\link[=slice_group_sample]{slice_group_sample()}}
}
}
