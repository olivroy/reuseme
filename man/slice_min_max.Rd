% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dplyr-plus.R
\name{slice_min_max}
\alias{slice_min_max}
\title{Subset rows using their positions}
\usage{
slice_min_max(
  .data,
  order_by,
  ...,
  n,
  prop,
  by = NULL,
  with_ties = TRUE,
  na_rm = FALSE,
  each = TRUE,
  ascending = TRUE
)
}
\arguments{
\item{.data}{A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See \emph{Methods}, below, for
more details.}

\item{order_by}{<\code{\link[rlang:args_data_masking]{data-masking}}> Variable or
function of variables to order by. To order by multiple variables, wrap
them in a data frame or tibble.}

\item{...}{Arguments are passed on to methods.}

\item{n, prop}{Provide either \code{n}, the number of rows, or \code{prop}, the
proportion of rows to select. If neither are supplied, \code{n = 1} will be
used. If \code{n} is greater than the number of rows in the group
(or \code{prop > 1}), the result will be silently truncated to the group size.
\code{prop} will be rounded towards zero to generate an integer number of
rows.

A negative value of \code{n} or \code{prop} will be subtracted from the group
size. For example, \code{n = -2} with a group of 5 rows will select 5 - 2 = 3
rows; \code{prop = -0.25} with 8 rows will select 8 * (1 - 0.25) = 6 rows.}

\item{by}{\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

<\code{\link[dplyr:dplyr_tidy_select]{tidy-select}}> Optionally, a selection of columns to
group by for just this operation, functioning as an alternative to \code{\link[dplyr:group_by]{group_by()}}. For
details and examples, see \link[dplyr:dplyr_by]{?dplyr_by}.}

\item{with_ties}{Should ties be kept together? The default, \code{TRUE},
may return more rows than you request. Use \code{FALSE} to ignore ties,
and return the first \code{n} rows.}

\item{na_rm}{Should missing values in \code{order_by} be removed from the result?
If \code{FALSE}, \code{NA} values are sorted to the end (like in \code{\link[dplyr:arrange]{arrange()}}), so
they will only be included if there are insufficient non-missing values to
reach \code{n}/\code{prop}.}

\item{each}{If \code{FALSE}, \code{n} and \code{prop} passed to \code{dplyr::slice_min()} and
\code{dplyr::slice_max()} will be divided by 2. (will use \code{ceiling()} if n is)}

\item{ascending}{Return the output in ascending order. (min on top)}
}
\value{
An object of the same type as \code{.data.}
The output has the following properties:
\itemize{
\item Each row may appear 0, 1, or many times in the output.
\item A \code{minmax} column is added to show which is min, which is max.
\item Groups are not modified.
\item Data frame attributes are preserved.
}
}
\description{
A wrapper around \code{dplyr::bind_rows()}, \code{dplyr::slice_min()}, \code{dplyr::slice_max()}
}
\examples{
# in the presence of ties.
library(magrittr)
mtcars \%>\% dplyr::slice_min(cyl, n = 1)
# Use with_ties = FALSE to return exactly n matches
mtcars \%>\% dplyr::slice_min(cyl, n = 1, with_ties = FALSE)
# Use each = FALSE to have n divided in each place
mtcars \%>\% slice_min_max(cyl, n = 2)
# Using each = TRUE (to retun n = 2, for min, n = 2 for max)
mtcars \%>\% slice_min_max(cyl, each = TRUE, n = 2)
}
\seealso{
Other dplyr extensions: 
\code{\link{count_pct}()}
}
\concept{dplyr extensions}
